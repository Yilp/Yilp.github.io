<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yilp的博客</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://yilp.github.io/atom.xml" rel="self"/>
  
  <link href="https://yilp.github.io/"/>
  <updated>2022-09-21T04:34:28.233Z</updated>
  <id>https://yilp.github.io/</id>
  
  <author>
    <name>Yilp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读取、划分数据集</title>
    <link href="https://yilp.github.io/2022/09/21/%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://yilp.github.io/2022/09/21/%E8%AF%BB%E5%8F%96%E3%80%81%E5%88%92%E5%88%86%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2022-09-20T23:29:48.000Z</published>
    <updated>2022-09-21T04:34:28.233Z</updated>
    
    <content type="html"><![CDATA[<p><strong>总结了常见的数据集读取方法以及对数据集的划分</strong></p><span id="more"></span><p>对于图片数据集，<strong>主要有两种形式</strong>：标签在文件夹上和标签在文件命名上，其中，标签为单独的csv文件也属于标签在文件夹上这一类。</p><h1 id="一、数据集读取"><a href="#一、数据集读取" class="headerlink" title="一、数据集读取"></a><strong>一、数据集读取</strong></h1><h2 id="1-标签在文件夹上："><a href="#1-标签在文件夹上：" class="headerlink" title="1.标签在文件夹上："></a><strong>1.标签在文件夹上：</strong></h2><p><strong>数据集</strong>：有各个类别的文件夹，每个文件夹的命名即为标签。</p><p><strong>加载方法</strong>：直接使用 <strong>torchvision.datasets.Imagefolder</strong> 加载数据，再利用<strong>torch.utils.data.DataLoader</strong> 装进<strong>DataLoader</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mydataset = torchvision.datasets.ImageFolder(root=<span class="string">&quot;E:/Code/PycharmProject/Dataset_dataload/Datasets/dogcat/train&quot;</span>, transform=data_transform)</span><br><span class="line"></span><br><span class="line">dataset_loader = torch.utils.data.DataLoader(Mydataset,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="标签为单独的csv文件"><a href="#标签为单独的csv文件" class="headerlink" title="标签为单独的csv文件"></a>标签为单独的csv文件</h3><p><strong>数据集：</strong>1个训练集文件夹，标签为csv文件</p><p>需要转换成标签在文件夹上的形式</p><p><strong>加载方法</strong>：先读取训练集路径和标签，建立各个类别的文件夹，然后将各类数据分别复制到相应的文件夹里，然后<strong>Imagefolder</strong> 加载数据，装进<strong>DataLoader</strong></p><h2 id="2-标签在文件命名上"><a href="#2-标签在文件命名上" class="headerlink" title="2.标签在文件命名上"></a><strong>2.标签在文件命名上</strong></h2><p><strong>数据集：</strong>1个训练集文件夹，标签在文件命名上</p><p><strong>加载方法：</strong>利用继承<strong>torch.utils.data.Dataset</strong>类 来创建数据集,然后装进<strong>DataLoader</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>): <span class="comment">#继承Dataset</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path_dir, transform=<span class="literal">None</span></span>): <span class="comment">#初始化一些属性</span></span><br><span class="line">        self.path_dir = path_dir <span class="comment">#文件夹路径</span></span><br><span class="line">        self.transform = transform <span class="comment">#对图形进行处理，如标准化、截取、转换等</span></span><br><span class="line">        self.images = os.listdir(self.path_dir)<span class="comment">#路径下的所有文件的文件名放列表中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.images) <span class="comment">#返回整个数据集的大小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):<span class="comment">#根据索引index返回图像及标签</span></span><br><span class="line">        image_index = self.images[index]<span class="comment">#根据索引获取图像文件名称</span></span><br><span class="line">        img_path = os.path.join(self.path_dir, image_index)<span class="comment">#单幅图像的绝对路径</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&#x27;RGB&#x27;</span>)<span class="comment"># 读取图像</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据目录名称获取图像标签（cat或dog）</span></span><br><span class="line">        label = img_path.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#把字符转换为数字cat--0，dog--1</span></span><br><span class="line">        label = <span class="number">1</span> <span class="keyword">if</span> <span class="string">&#x27;dog&#x27;</span> <span class="keyword">in</span> label <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="keyword">return</span> img,label</span><br></pre></td></tr></table></figure><h1 id="二、数据集划分训练集、验证集"><a href="#二、数据集划分训练集、验证集" class="headerlink" title="二、数据集划分训练集、验证集"></a><strong>二、数据集划分训练集、验证集</strong></h1><p><strong>数据集划分方法很多，记录两种使用过的以及一些更简单的方法。</strong></p><ul><li><p><strong>1</strong>.在读取标签为csv文件的数据集时，需要将数据集复制到各类文件夹里，此时划分训练集、验证集，设置好验证集比例，将每个种类的一部分数据复制到验证集的对应种类的文件夹里，即划分数据集完成。</p></li><li><p><strong>2</strong>.利用继承<strong>Dataset</strong>类</p></li></ul><p><strong>更简单的几种方法</strong></p><ul><li><strong>torch.utils.data.random_split</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_size = <span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(full_dataset))</span><br><span class="line">test_size = <span class="built_in">len</span>(full_dataset) - train_size</span><br><span class="line">train_dataset, test_dataset = torch.utils.data.random_split(full_dataset, [train_size, test_size])</span><br></pre></td></tr></table></figure><ul><li>**torch.utils.data.SubsetRandomSampler(indices)**：无放回地按照给定的索引列表采样样本元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dataset = MyCustomDataset(my_path)</span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">validation_split = <span class="number">.2</span></span><br><span class="line">shuffle_dataset = <span class="literal">True</span></span><br><span class="line">random_seed= <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating data indices for training and validation splits:</span></span><br><span class="line">dataset_size = <span class="built_in">len</span>(dataset)</span><br><span class="line">indices = <span class="built_in">list</span>(<span class="built_in">range</span>(dataset_size))</span><br><span class="line">split = <span class="built_in">int</span>(np.floor(validation_split * dataset_size))  <span class="comment"># 验证集样本数</span></span><br><span class="line"><span class="keyword">if</span> shuffle_dataset :</span><br><span class="line">    np.random.seed(random_seed)</span><br><span class="line">    np.random.shuffle(indices)</span><br><span class="line">train_indices, val_indices = indices[split:], indices[:split]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating PT data samplers and loaders:</span></span><br><span class="line">train_sampler = SubsetRandomSampler(train_indices)</span><br><span class="line">valid_sampler = SubsetRandomSampler(val_indices)</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, </span><br><span class="line">                                           sampler=train_sampler)</span><br><span class="line">validation_loader = torch.utils.data.DataLoader(dataset, batch_size=batch_size,</span><br><span class="line">                                                sampler=valid_sampler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage Example:</span></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="comment"># Train:   </span></span><br><span class="line">    <span class="keyword">for</span> batch_index, (faces, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;总结了常见的数据集读取方法以及对数据集的划分&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="pytorch" scheme="https://yilp.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>英语单词</title>
    <link href="https://yilp.github.io/2022/08/23/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"/>
    <id>https://yilp.github.io/2022/08/23/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/</id>
    <published>2022-08-23T00:47:33.000Z</published>
    <updated>2022-09-09T01:14:50.430Z</updated>
    
    <content type="html"><![CDATA[<p>记录不认识的单词</p><span id="more"></span><p>colums  列</p><p>rows  行</p><p>Flip and Crop  翻转和裁剪</p><p>saturation  饱和度  </p><p>hue   色调, 色彩, 颜色</p><p>Horizontal  水平的</p><p>ratio 比率</p><p>image augmentation  图像增广   （啊哥美tation）</p><p>subscriptable  可下标的</p><p>horizontal  水平的</p><p>hue 色调</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录不认识的单词&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://yilp.github.io/2022/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://yilp.github.io/2022/08/22/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-08-22T08:52:10.000Z</published>
    <updated>2022-09-13T07:29:19.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>记录一些常用命令</p><span id="more"></span><p>重启：init 6或 reboot（虚拟机上）</p><p>关机： init0或 halt</p><p>清屏： clear</p><p>查看服务器地址：ip addr</p><p>时间： date</p><p>复制粘贴：Ctrl+insert    Shift+ins</p><p>终止命令： ctrl +c</p><p><strong>目录</strong></p><p>pwd 查看当前目录</p><p>cd 目录名  进入目录</p><p>cd .. 进入上级目录</p><p>cd  进入主目录</p><p>ls 列出当前目录</p><p>ls -l    列出当前目录详细信息 (显示的d是目录，-是文件)   目录和文件有严格的权限</p><p>ls -l 具体目录   ls /具体目录</p><p><strong>“./“：代表目前所在的目录。</strong></p><p><strong>“ . ./“代表上一层目录。</strong></p><p><strong>“/“：代表根目录。</strong></p><p>/        表示根目录<br>./       表示当前目录<br>../      表示父级（上一级）目录<br>../../   表示文件所在的父级目录的父级目录</p><p><strong>正则表达式</strong>：</p><p>*匹配任意字符</p><p>ls _f*  列出某类文件</p><p>ls _*.h</p><p>ls *.h</p><p><strong>？匹配一个字符</strong></p><p>ls -lt 按时间降序</p><p><strong>创建目录</strong></p><p>mkdir aaa/bbb  使用的当前目录 ，</p><p>mkdir /aaa/bbb</p><p>删除目录</p><p>rm  -r aaa   -r 删除目录</p><p>rm  -rf aaa   -r删除目录不询问</p><p>rm bbb 删除文件</p><p>rm -f bbb 删除文件不提示</p><p><strong>移动文件目录</strong></p><p>选择文件或者目录  mv 名字 重命名     然后  mv 重命名 目录</p><p><em><strong>复制</strong></em>  cp  和删除目录一样的有r</p><p><strong>打包和压缩</strong></p><p>打包 tar zcvf 压缩后的文件名.tgz（绝对路径） 目录、文件</p><p>解压 ta zxvf </p><p>tar打包的文件，winar可以打开</p><p><strong>文本内容</strong></p><ul><li>显示内容 <strong>cat、more和tail。</strong></li></ul><p>cat 文件名，一次显示整个文件的内容。</p><p>more 文件名 ，分页显示，按空格键显示下一页，按b键显上一页，按q键退出。</p><p>tail -f 文件名   显示最后几行，如果文件的内容有增加，就实时的刷新</p><ul><li>搜索内容</li></ul><p>搜索文件中的内容    grep “内容” 文件名 grep max <em>.c  在</em>.c文件中搜索max内容</p><p>搜索文件  find 目录名 -name 文件名 -print </p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>su - root 切换root用户</p><p>su - 用户名</p><p>df [-h] [-T]</p><p>选项-h 以方便阅读的方式显示信息。</p><p>选项-T 列出文件系统类型</p><p><strong>目录和文件</strong></p><p>可以看作只有一个盘</p><p>Windows下\   Linux /</p><p>文件名严格讲是由目录+文件名组成，绝对目录是从 \根 算起</p><p>登录Linux时，处于目录树的某个目录下，这个目录为当前目录</p><p>相对路径是从当前目录算起的，如 <strong>/a/b/c.text</strong> , 当前目录为/a/b, c.txt = /a/b/c.text</p><p>. 当前目录</p><p>.. 当前目录的上一级目录</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;&lt;p&gt;记录一些常用命令&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://yilp.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python语法记录</title>
    <link href="https://yilp.github.io/2022/08/11/python%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://yilp.github.io/2022/08/11/python%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-11T06:35:16.000Z</published>
    <updated>2022-09-15T07:34:32.410Z</updated>
    
    <content type="html"><![CDATA[<p>记录python不熟悉的语法</p><span id="more"></span><h2 id="1-if-name-‘-main-‘："><a href="#1-if-name-‘-main-‘：" class="headerlink" title="1.if name == ‘__main__‘："></a>1.if <strong>name</strong> == ‘__main__‘：</h2><p>一个Python文件有两种运行方式，1个是作为脚本直接运行，另一个是作为模块import，而if <strong>name</strong> == ‘__main__‘ 里的代码只有在第1个的情况下才会运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == ‘__main__‘:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;two&quot;</span>)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line"><span class="comment"># one</span></span><br><span class="line"><span class="comment"># two</span></span><br></pre></td></tr></table></figure><p>原理是作为模块导入时，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__name__ <span class="comment"># 指模块的名称</span></span><br><span class="line">__main__ <span class="comment"># 永远指当前运行的脚本</span></span><br><span class="line">__name__ ！= ‘__main__‘ </span><br></pre></td></tr></table></figure><h2 id="2-time-clock-，代码提示有该属性，但就是报错"><a href="#2-time-clock-，代码提示有该属性，但就是报错" class="headerlink" title="2.time.clock()，代码提示有该属性，但就是报错"></a>2.time.clock()，代码提示有该属性，但就是报错</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.perf_counter() <span class="comment">#替换即可计时</span></span><br></pre></td></tr></table></figure><h2 id="3-if-isinstance-X-list"><a href="#3-if-isinstance-X-list" class="headerlink" title="3.if isinstance(X, list):"></a>3.if isinstance(X, list):</h2><p>判断变量类型的函数，既可以是python内置的数据类型如 <strong>list、dict、str</strong>，也可以是自定义的类。</p><h2 id="4-numel"><a href="#4-numel" class="headerlink" title="4.numel()"></a>4.numel()</h2><p>返回数组中元素的个数</p><h2 id="5-apply-model-apply-fn-或net-apply-fn"><a href="#5-apply-model-apply-fn-或net-apply-fn" class="headerlink" title="5.apply(), model.apply(fn)或net.apply(fn)"></a>5.apply(), model.apply(fn)或net.apply(fn)</h2><p>任何网络都是 torch.nn.Module 的子类，都算Module。</p><p>apply会递归的应用fn到每个子模块，然后是应用到模块本身（即先子后父），返回的是Module</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        m.weight.fill_(<span class="number">1.0</span>)</span><br><span class="line">        <span class="built_in">print</span>(m.weight)</span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>,<span class="number">4</span>), nn.Linear(<span class="number">4</span>, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(net)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;isinstance torch.nn.Module&#x27;</span>,<span class="built_in">isinstance</span>(net,torch.nn.Module))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">net.apply(init_weights)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (<span class="number">1</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">isinstance</span> torch.nn.Module <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">Linear(in_features=<span class="number">2</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line">Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">4</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (<span class="number">1</span>): Linear(in_features=<span class="number">4</span>, out_features=<span class="number">8</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-函数和函数调用的区别"><a href="#6-函数和函数调用的区别" class="headerlink" title="6.函数和函数调用的区别"></a>6.函数和函数调用的区别</h2><p>f 是一个函数，它的值是函数本身， f( )是函数的调用，它的值是函数的执行结果</p><p>在被装饰函数定义阶段，也就是函数调用之前：</p><h2 id="7-装饰器"><a href="#7-装饰器" class="headerlink" title="7.装饰器"></a>7.装饰器</h2><p>python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1111&quot;</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">one</span>():  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2222&quot;</span>)  </span><br><span class="line">        func()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3333&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> one  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">func</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aaaa&quot;</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">two</span>():  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bbbb&quot;</span>)  </span><br><span class="line">        func()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cccc&quot;</span>)  </span><br><span class="line">    <span class="keyword">return</span> two  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@dec1  </span></span><br><span class="line"><span class="meta">@dec2  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test test&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">test()  </span><br><span class="line"><span class="comment"># aaaa  </span></span><br><span class="line"><span class="comment"># 1111  </span></span><br><span class="line"><span class="comment"># 2222  </span></span><br><span class="line"><span class="comment"># bbbb  </span></span><br><span class="line"><span class="comment"># test test  </span></span><br><span class="line"><span class="comment"># cccc  </span></span><br><span class="line"><span class="comment"># 3333</span></span><br><span class="line"><span class="comment"># 不调用test() 也有输出  aaaa 1111</span></span><br></pre></td></tr></table></figure><p><strong>加断点测试更清楚</strong></p><p><strong>多个装饰函数的调用顺序</strong></p><p>函数定义阶段：执行顺序是从最靠近函数的装饰器开始，自内而外的执行</p><p>函数执行阶段：执行顺序由外而内，一层层执行</p><p>@b</p><p>@a</p><p>定义时，相当于套盒子，先套a盒子，再套b盒子</p><p>使用时，先拆b盒子（b产生了新函数），再拆a盒子（a也产生新盒子）</p><h2 id="8-格式化字符串f-string"><a href="#8-格式化字符串f-string" class="headerlink" title="8.格式化字符串f-string"></a>8.格式化字符串f-string</h2><p>f-string在形式上是以 <code>f</code> 或 <code>F</code> 修饰符引领的字符串（<code>f&#39;xxx&#39;</code> 或 <code>F&#39;xxx&#39;</code>），以大括号 <code>&#123;&#125;</code> 标明被替换的字段，可以是<strong>变量、表达式、函数调用</strong>。</p><p><strong>注意</strong>：</p><p>—.{}括号里的引号不能与外面的定界符引号发生冲突，可以使用双引号、三引号避免。</p><p>—.括号内不能出现转义字符\，即使要出现，也要用变量代替。</p><h2 id="9-matplotlib-inline"><a href="#9-matplotlib-inline" class="headerlink" title="9.%matplotlib inline"></a>9.%matplotlib inline</h2><p>可以在Ipython编译器里直接使用，功能是可以内嵌绘图，并且可以省略掉plt.show()这一步。</p><p>是在使用jupyter notebook 或者 jupyter qtconsole的时候，才会经常用到%matplotlib</p><p>而%matplotlib具体作用是当你调用matplotlib.pyplot的绘图函数plot()进行绘图的时候，或者生成一个figure画布的时候，可以直接在你的python console里面生成图像。</p><h2 id="10-numpy"><a href="#10-numpy" class="headerlink" title="10.numpy"></a>10.numpy</h2><h3 id="np-newaxis"><a href="#np-newaxis" class="headerlink" title="-np.newaxis"></a>-np.newaxis</h3><p>np.newaxis的功能:插入新的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在插入np.newaxis处增加1个维度</span></span><br><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">aa=a[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(aa.shape)</span><br><span class="line"><span class="built_in">print</span> (aa)</span><br><span class="line"><span class="comment"># 输出：(5, 1)</span></span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment"># [2]</span></span><br><span class="line"><span class="comment"># [3]</span></span><br><span class="line"><span class="comment"># [4]</span></span><br><span class="line"><span class="comment"># [5]]</span></span><br></pre></td></tr></table></figure><h3 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="-np.concatenate"></a>-np.concatenate</h3><p>np.concatenate 是numpy中对array进行拼接的函数，使用方法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1=np.random(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">x2=np.random(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">y=np.concatenate([x1,x2],axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="comment"># (5,6)</span></span><br></pre></td></tr></table></figure><p>拼接的维度必须对的上</p><h3 id="变化数组类型"><a href="#变化数组类型" class="headerlink" title="-变化数组类型"></a>-变化数组类型</h3><ul><li><p>方法一</p><p> ndarray. <strong>astype</strong> (np.float32)</p></li><li><p>方法二</p><p> float_array = np. <strong>array</strong> ([1.23,3.14,5.12,3.23],dtype=float)  重新定义</p></li></ul><h3 id="ndarry-ravel-和-ndarry-flatten"><a href="#ndarry-ravel-和-ndarry-flatten" class="headerlink" title="ndarry.ravel() 和 ndarry.flatten()"></a>ndarry.ravel() 和 ndarry.flatten()</h3><p>实现功能一样：将多维数组降为一维。</p><p>但前者传址，后者传值</p><p>具体参考<a href="https://blog.csdn.net/liuweiyuxiang/article/details/78220080?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166296779516781432974506%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166296779516781432974506&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-78220080-null-null.nonecase&amp;utm_term=ravel()&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/liuweiyuxiang/article/details/78220080?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166296779516781432974506%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166296779516781432974506&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-78220080-null-null.nonecase&amp;utm_term=ravel%28%29&amp;spm=1018.2226.3001.4450</a></p><h2 id="11-os-path-splitext-与os-path-split-的用法和区别"><a href="#11-os-path-splitext-与os-path-split-的用法和区别" class="headerlink" title="11.os.path.splitext()与os.path.split()的用法和区别"></a>11.os.path.splitext()与os.path.split()的用法和区别</h2><ul><li>区别</li></ul><p>#os.path.splitext() 将文件名和扩展名分开，返回 路径/文件名 ，拓展名</p><p>#os.path.split() 返回文件的路径和文件名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path=<span class="string">&quot;E:/Code/PycharmProject/Dl2/VGG.py&quot;</span></span><br><span class="line">os.path.split(path)  <span class="comment"># (&#x27;E:/Code/PycharmProject/Dl2&#x27;, &#x27;VGG.py&#x27;)</span></span><br><span class="line">os.path.splitext(path) <span class="comment"># (&#x27;E:/Code/PycharmProject/Dl2/VGG&#x27;, &#x27;.py&#x27;) 返回的字符串</span></span><br></pre></td></tr></table></figure><ul><li>os.path.split()  的使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">&quot;hello.world.python&quot;</span></span><br><span class="line"><span class="built_in">print</span> string.split(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 输出为：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(string.split(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)) <span class="comment"># 输出为：[&#x27;hello&#x27;, &#x27;world.python&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(string.split(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)[<span class="number">0</span>]) <span class="comment"># 输出为：hello</span></span><br><span class="line"><span class="built_in">print</span>(string.split(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)[<span class="number">1</span>]) <span class="comment"># 输出为：world.python</span></span><br></pre></td></tr></table></figure><h2 id="12-python文件读取"><a href="#12-python文件读取" class="headerlink" title="12.python文件读取"></a>12.python文件读取</h2><h3 id="open-函数注意点"><a href="#open-函数注意点" class="headerlink" title="-open()函数注意点"></a>-<strong>open()函数注意点</strong></h3><ul><li><strong>读取静态文件的函数，最好不要写相对路径！！！</strong>其他文件引用读取静态文件的函数时，相对路径是从其他文件开始算的，而不是原文件的路径开始算，很有可能报错</li><li>跳过第一行内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">next</span>(f)<span class="comment"># 最终读取到的内容，直接跳过第一行了</span></span><br><span class="line">all_line_list = f.readlines()</span><br></pre></td></tr></table></figure><ul><li>写文件和读文件时一样的</li><li>分词和统计</li></ul><h3 id="文件读取的4种方式"><a href="#文件读取的4种方式" class="headerlink" title="- 文件读取的4种方式"></a>- <strong>文件读取的4种方式</strong></h3><ul><li>打开文件后直接读取，循环输出时每行是一个字符串<strong>str</strong></li><li>用 <strong>read()</strong> 读取 ，全部内容一次性读到一个字符串中，循环输出时是1个1个的字符<strong>read(size)</strong>: 每次读取size个字节内容，避免文件打内存爆掉</li><li>用 <strong>readlines()</strong> 读取，将文件的内容以行区分，输出到一个列表，列表中的每个元素是源文件的一行内容。</li><li>用 <strong>readline()</strong> 读取，  一行一行的读，是字符串，非常省内存。只读一行，第二次读取时自动读取下一行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>（<span class="string">&#x27;单行数据&#x27;</span>，line）</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ff=f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines=f.readlines().strip() </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># strip()</span></span><br><span class="line"><span class="comment"># 读取文件之后，文字末尾会出现&#x27;\n&#x27;</span></span><br><span class="line"><span class="comment"># strip() 函数中可以把目标内容line里面所有的空格，空行等都删除掉，只剩余文字内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line =f.readline()  <span class="comment"># 第一行 </span></span><br><span class="line">    line =f.readline()  <span class="comment"># 第二行 </span></span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        line=f.readline()</span><br></pre></td></tr></table></figure><h3 id="读取文件下图片的方法"><a href="#读取文件下图片的方法" class="headerlink" title="-读取文件下图片的方法"></a>-<strong>读取文件下图片的方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="comment">#读取images文件夹下所有文件的名字</span></span><br><span class="line">imagelist = os.listdir(<span class="string">&#x27;./images/&#x27;</span>)</span><br><span class="line"><span class="comment">#读取带有相同关键字的图片名字，比上一种方法好</span></span><br><span class="line">imagelist= <span class="built_in">sorted</span>(glob.glob(<span class="string">&#x27;./images/&#x27;</span> + <span class="string">&#x27;frame_*.png&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="13-string-rstrip-和strip-的区别"><a href="#13-string-rstrip-和strip-的区别" class="headerlink" title="13.string.rstrip() 和strip()的区别"></a>13.string.rstrip() 和strip()的区别</h2><p><strong>strip()</strong> 方法用于移除字符串<strong>头尾</strong>指定的字符（默认为空格或换行符）或字符序列。<br><strong>rstrip()</strong> 删除 string 字符串<strong>末尾</strong>的指定字符（默认为空格）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;     this is string example....wow!!!     &quot;</span></span><br><span class="line">str2 = str1.rstrip()  <span class="comment"># &quot;     this is string example....wow!!!&quot;</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;88888888this is string example....wow!!!8888888&quot;</span></span><br><span class="line">str2 = str2.strip(<span class="string">&quot;8&quot;</span>)  <span class="comment"># &quot;this is string example....wow!!!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="14-字典dict"><a href="#14-字典dict" class="headerlink" title="14.字典dict"></a>14.字典dict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明</span></span><br><span class="line">my_dict = &#123;key1:value1, key2:value2&#125;</span><br><span class="line"></span><br><span class="line">dict0 = <span class="built_in">dict</span>()  <span class="comment"># 1、传一个空字典</span></span><br><span class="line">dict1 = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">24</span>&#125;)  <span class="comment"># 2、传一个字典</span></span><br><span class="line">dict2 = <span class="built_in">dict</span>(user=<span class="string">&#x27;admin&#x27;</span>, password=<span class="number">123456</span>)  <span class="comment"># 3、传关键字</span></span><br><span class="line"><span class="comment"># dict2: &#123;&#x27;user&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: 123456&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>字典的键是唯一的，不可重复。新增的重复 健值对 会覆盖前面的。</p></li><li><p>值可以取任何数据类型，但键必须是不可变的，如字符串、数字或元组。</p></li><li><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update() 只添加dict中没有的key-value,已经有key则更新其value</span></span><br><span class="line">x = &#123;<span class="number">1</span>:<span class="number">2</span>&#125;</span><br><span class="line">d1 = &#123;<span class="number">3</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">6</span>, <span class="number">7</span>:<span class="number">8</span>&#125;</span><br><span class="line">x.update(d1)  <span class="comment"># x &#123;1: 2, 3: 4, 5: 6, 7: 8&#125;</span></span><br><span class="line"></span><br><span class="line">d2 = &#123;<span class="number">1</span>:<span class="number">2</span>&#125;</span><br><span class="line">x.update(d2)  <span class="comment"># x &#123;1: 2, 3: 4, 5: 6, 7: 8&#125;</span></span><br><span class="line"></span><br><span class="line">d3 = &#123;<span class="number">1</span>:<span class="number">3</span>&#125;</span><br><span class="line">x.update(d3)  <span class="comment"># x &#123;1: 3, 3: 4, 5: 6, 7: 8&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lines = [<span class="string">&#x27;1,2&#x27;</span>,<span class="string">&#x27;3,4&#x27;</span>,<span class="string">&#x27;5,6&#x27;</span>]</span><br><span class="line">tokens = [line.rstrip().split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">idx_label = <span class="built_in">dict</span>(((idx, label) <span class="keyword">for</span> idx, label <span class="keyword">in</span> tokens))</span><br><span class="line"><span class="comment"># tokens [[&#x27;1&#x27;, &#x27;2&#x27;], [&#x27;3&#x27;, &#x27;4&#x27;], [&#x27;5&#x27;, &#x27;6&#x27;]]</span></span><br><span class="line"><span class="comment"># idx_label &#123;&#x27;1&#x27;: &#x27;2&#x27;, &#x27;3&#x27;: &#x27;4&#x27;, &#x27;5&#x27;: &#x27;6&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">lines = [<span class="string">&#x27;1,2&#x27;</span>,<span class="string">&#x27;3,4&#x27;</span>,<span class="string">&#x27;5,6&#x27;</span>]</span><br><span class="line">idx_label =<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    idx, label=line.rstrip().split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    idx_label.update(&#123;idx:label&#125;)</span><br><span class="line"><span class="comment"># idx_label &#123;&#x27;1&#x27;: &#x27;2&#x27;, &#x27;3&#x27;: &#x27;4&#x27;, &#x27;5&#x27;: &#x27;6&#x27;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcit.values() <span class="meta"># 返回 值 的列表</span></span><br></pre></td></tr></table></figure><h2 id="15-set-集合"><a href="#15-set-集合" class="headerlink" title="15.set()集合"></a>15.set()集合</h2><p>里面不能包含重复的元素，接收一个list作为参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">s=<span class="built_in">set</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#4</span></span><br></pre></td></tr></table></figure><p>有添加、删除元素，还可以求交集、并集</p><p><strong>set.add()        set.remove()</strong></p><p><strong>set1&amp;set2        set1|set2</strong></p><h2 id="16-Counter-计数器"><a href="#16-Counter-计数器" class="headerlink" title="16.Counter()计数器"></a>16.Counter()计数器</h2><p><strong>主要功能</strong>：可以支持方便、快速的计数，将<strong>元素数量统计</strong>，然后计数并<strong>返回一个字典</strong>，键为元素，值为元素个数。</p><p>最简单的一个使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">c = Counter(colors) <span class="comment"># Counter(&#123;&#x27;red&#x27;: 2, &#x27;blue&#x27;: 3, &#x27;green&#x27;: 1&#125;)</span></span><br><span class="line"><span class="built_in">dict</span>(c) <span class="comment"># &#123;&#x27;red&#x27;: 2, &#x27;blue&#x27;: 3, &#x27;green&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Counter</strong>操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的Counter：</span></span><br><span class="line">cnt = Counter()</span><br><span class="line"><span class="comment"># 判断是否包含某元素</span></span><br><span class="line">c = Counter([<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>])</span><br><span class="line">c[<span class="string">&#x27;bacon&#x27;</span>] <span class="comment"># 0 不存在就返回0</span></span><br><span class="line"><span class="comment"># 删除元素：</span></span><br><span class="line">c[<span class="string">&#x27;sausage&#x27;</span>] = <span class="number">0</span>                      </span><br><span class="line"><span class="keyword">del</span> c[<span class="string">&#x27;sausage&#x27;</span>]   </span><br><span class="line"><span class="comment"># 获得所有元素:</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">list</span>(c.elements()) <span class="comment"># [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment"># 查看最常见出现的k个元素：</span></span><br><span class="line">Counter(<span class="string">&#x27;abracadabra&#x27;</span>).most_common(<span class="number">3</span>) <span class="comment">#[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)]</span></span><br></pre></td></tr></table></figure><ul><li><strong>Counter对象支持以下三个字典不支持的方法,update()字典支持</strong><ul><li><strong>most_common()</strong> 如果忽略n或者为None，会返回counter中的所有元素</li><li><strong>elements()</strong> </li><li><strong>update()</strong> 另一个映射（或counter）中所有元素相加，是数目相加</li><li>**subtract() ** 另一个映射（或counter）中，元素相减，是数目相减</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(c.values())  <span class="comment"># 所有计数的总数</span></span><br><span class="line">c.clear()  <span class="comment"># 重置Counter对象，注意不是删除</span></span><br><span class="line"><span class="built_in">list</span>(c)  <span class="comment"># 将c中的键转为列表</span></span><br><span class="line"><span class="built_in">set</span>(c)  <span class="comment"># 将c中的键转为set</span></span><br><span class="line"><span class="built_in">dict</span>(c)  <span class="comment"># 将c中的键值对转为字典</span></span><br><span class="line">c.items()  <span class="comment"># 转为(elem, cnt)格式的列表</span></span><br><span class="line">Counter(<span class="built_in">dict</span>(list_of_pairs))  <span class="comment"># 从(elem, cnt)格式的列表转换为Counter类对象</span></span><br><span class="line">c.most_common()[:-n:-<span class="number">1</span>]  <span class="comment"># 取出计数最少的n-1个元素</span></span><br><span class="line">c += Counter()  <span class="comment"># 移除0和负值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="17-lambda表达式"><a href="#17-lambda表达式" class="headerlink" title="17.lambda表达式"></a>17.lambda表达式</h2><p>lambda可以定义一个匿名函数，而def定义的函数必须有一个名字。这应该是lambda与def两者最大的区别。</p><p>lambda语句中，冒号前是参数，可以有多个，用逗号隔开，冒号右边的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带参数</span></span><br><span class="line">bar = <span class="keyword">lambda</span>:<span class="string">&#x27;beginman&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bar())  <span class="comment"># beginman</span></span><br></pre></td></tr></table></figure><p>lambda排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对单个变量进行排序</span></span><br><span class="line"><span class="comment">#list = [[5,8],[5,3],[3,1]]</span></span><br><span class="line"><span class="built_in">list</span>.sort(key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>])  <span class="comment"># 以元素的第二个元素升序排列</span></span><br><span class="line"><span class="comment">#list = [[3,1],[5,8],[5,3]]</span></span><br></pre></td></tr></table></figure><h2 id="18-sort"><a href="#18-sort" class="headerlink" title="18.sort()"></a>18.sort()</h2><ul><li>函数 <strong>sort（）</strong>是对列表就地排序, 不返回任何值, 函数<strong>sort（）</strong>是升序排序，如何降序排序，需要用到函数reverse（）。区别**sorted()**函数会返回一个排序列表，不改变原有序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">x.sort()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line">x = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">y = x.sort()</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line">x = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">y = <span class="built_in">sorted</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># [8, 9, 0, 7, 4, 5, 1, 2, 3, 6]</span></span><br></pre></td></tr></table></figure><ul><li><p>函数 **sort（) **排序的高级用法</p><p>方法<strong>sort（）</strong>可以接受两个参数<strong>sort（key,reverse）</strong></p><p><strong>key</strong>：只有1个形参的函数，key接受的函数返回值，表示此元素的权值，sort将按照权值大小进行排序。</p><p><strong>reverse</strong>：接受的是一个bool类型的值 (Ture or False), 表示是否颠倒排列顺序,一般默认的是False</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">a</span>):</span><br><span class="line">    x=<span class="number">10</span>-<span class="built_in">int</span>(a)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">x.sort(key=size)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure><h2 id="19-os-makedirs-和os-mkdir"><a href="#19-os-makedirs-和os-mkdir" class="headerlink" title="19.os.makedirs()和os.mkdir()"></a>19.os.makedirs()和os.mkdir()</h2><ul><li><strong>os.makedirs()<strong>用来创建</strong>多层</strong>目录，**os.mkdir()**创建单层目录</li></ul><p>有/home，想新建/home/Arsmart/python就叫多层，新建/home/Arsmart叫单层。</p><ul><li><p><strong>os.mkdir() 函数</strong><br>语法格式：*<em>os.mkdir(path, mode=0o777, <em>, dir_fd=None)</em></em></p><p>使用数字模式mode创建名为path的目录。如果目录已经存在，则抛出异常FileExistsError。</p></li><li><p><strong>os.makedirs()函数</strong><br>语法格式： <strong>os.makedirs(name, mode=0o777, exist_ok=False)</strong><br>递归创建目录，即路径中哪一层不存在，则自动创建。<br>区别于os.mkdir(path, mode=0o777, *, dir_fd=None)，只创建最后一层的目录。<br>如果exist_ok是False（默认），当目标目录（即要创建的目录）已经存在，会抛出一个OSError。</p></li></ul><h2 id="20-shutil复制文件到指定目录"><a href="#20-shutil复制文件到指定目录" class="headerlink" title="20.shutil复制文件到指定目录"></a>20.shutil复制文件到指定目录</h2><ul><li><p><strong>shutil.copyfile(src，dst)</strong> 将文件 src 复制到 文件 dst 中，复制成功后返回 dst 完整路径；<strong>src，dst 需是文件路径而非文件目录</strong></p></li><li><p>**shutil.copy(src，dst) **作用与 shutil.copy(src，dst) 相同，用于文件复制；唯一区别是 shutil.copy() 中 dst 可为文件路径或文件目录（为文件名时是查看当前路径下有无这个文件）；</p></li><li><p><strong>shutil.copytree(src，dst)</strong> 将文件夹 src 中全部文件递归复制到 dst ，dst 若不存在时系统自动创建</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录python不熟悉的语法&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://yilp.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm报错、警告</title>
    <link href="https://yilp.github.io/2022/08/11/pycharm%E6%8A%A5%E9%94%99%E3%80%81%E8%AD%A6%E5%91%8A/"/>
    <id>https://yilp.github.io/2022/08/11/pycharm%E6%8A%A5%E9%94%99%E3%80%81%E8%AD%A6%E5%91%8A/</id>
    <published>2022-08-11T02:10:03.000Z</published>
    <updated>2022-08-23T09:51:45.612Z</updated>
    
    <content type="html"><![CDATA[<p>记录使用pycharm时出现错误和警告</p><span id="more"></span><h2 id="1-shadows-name-‘xxxx’-from-outer-scope-警告解决"><a href="#1-shadows-name-‘xxxx’-from-outer-scope-警告解决" class="headerlink" title="1.shadows name ‘xxxx’ from outer scope 警告解决"></a>1.shadows name ‘xxxx’ from outer scope 警告解决</h2><p>外部有个相同名称的变量在方法内部被重新指定了新的值，也就是说你在外部的相同名称的变量压根就没有任何作用。所以PyCharm就回提示这个信息。这个时候就需要我们去调整具体代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    param = <span class="string">&#x27;b&#x27;</span>  <span class="comment"># 这里就会出现这样的提示，因为在main定义的param对象被重新指定了新的值</span></span><br><span class="line">    <span class="built_in">print</span> param</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    param = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    a()</span><br></pre></td></tr></table></figure><h2 id="2-RuntimeError-An-attempt-has-been-made-to-start-a-new-process-before-the-current-process-has-finished-its-bootstrapping-phase"><a href="#2-RuntimeError-An-attempt-has-been-made-to-start-a-new-process-before-the-current-process-has-finished-its-bootstrapping-phase" class="headerlink" title="2.RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase."></a>2.RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase.</h2><pre><code>    This probably means that you are not using fork to start your    child processes and you have forgotten to use the proper idiom    in the main module:        if __name__ == &#39;__main__&#39;:            freeze_support()            ...    The &quot;freeze_support()&quot; line can be omitted if the program    is not going to be frozen to produce an executable.</code></pre><h2 id="3-module-‘torch-optim’-has-no-attribute-‘sgd’"><a href="#3-module-‘torch-optim’-has-no-attribute-‘sgd’" class="headerlink" title="3.module ‘torch.optim’ has no attribute ‘sgd’"></a>3.module ‘torch.optim’ has no attribute ‘sgd’</h2><p>虽然代码提示有sgd属性，但实际没有，只有SGD</p><h2 id="4-TypeError-‘tuple’-object-does-not-support-item-assignment"><a href="#4-TypeError-‘tuple’-object-does-not-support-item-assignment" class="headerlink" title="4.TypeError: ‘tuple’ object does not support item assignment"></a>4.TypeError: ‘tuple’ object does not support item assignment</h2><p>Tuple：tuple是另一种有序的列表，也称为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。</p><ul><li>创建tuple和创建list唯一不同之处是用( )替代了[ ]。</li><li>获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，也不能增加删减元素。</li></ul><ul><li>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。指向‘a’，就不能指向’b’。如果指向list，就不能改成指向其他对象，但指向的这个list本身是可变的！</li></ul><h1 id="5-one-of-the-variables-needed-for-gradient-computation-has-been-modified-by-an-inplace-operation"><a href="#5-one-of-the-variables-needed-for-gradient-computation-has-been-modified-by-an-inplace-operation" class="headerlink" title="5.one of the variables needed for gradient computation has been modified by an inplace operation"></a>5.one of the variables needed for gradient computation has been modified by an inplace operation</h1><p>计算梯度的时候检查出某个Variable有被一个 <code>inplace operation</code> 修改。是反向传播的过程中出错的。</p><p><strong>inplace operation</strong> 就是直接对tensor的内容进行修改，而没有使用复制的副本 （An in-place operation is an operation that changes directly the content of a given Tensor without making a copy）。</p><p>在pytorch中， inplace operation 可以是一些 .add_() 或 .scatter_() 导致的。对于.add_()方法，是直接在tensor上进行修改的，可以把x.add_(y)改成x = x + y。如果需要复制一个副本话，可以使用.clone()方法。</p><p>在python中， inplace operation 可以是一些 += 或 *= 导致的。比如 x += y，需要改成 x = x +y</p><h1 id="6-TypeError-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists"><a href="#6-TypeError-default-collate-batch-must-contain-tensors-numpy-arrays-numbers-dicts-or-lists" class="headerlink" title="6.TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists;"></a>6.TypeError: default_collate: batch must contain tensors, numpy arrays, numbers, dicts or lists;</h1><p><strong>报错原因：</strong>没有将数据转为torch的Tensor数据类型。</p><p><strong>解决方法</strong>：读取数据集时将数据转为Tensor数据类型即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最开始</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cifar10</span>(<span class="params">is_train, augs, batch_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取图像和应用图像增广&quot;&quot;&quot;</span></span><br><span class="line">    dataset = torchvision.datasets.CIFAR10(root=<span class="string">&quot;../data&quot;</span>, train=is_train,)</span><br><span class="line">    dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size,</span><br><span class="line">                                             shuffle=is_train, num_workers=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> dataloader</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cifar10</span>(<span class="params">is_train, augs, batch_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取图像和应用图像增广&quot;&quot;&quot;</span></span><br><span class="line">    dataset = torchvision.datasets.CIFAR10(root=<span class="string">&quot;../data&quot;</span>, train=is_train,</span><br><span class="line">                                           transform=torchvision.transforms.ToTensor())</span><br><span class="line">    dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size,</span><br><span class="line">                                             shuffle=is_train, num_workers=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> dataloader</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-cannot-unpack-non-iterable-NoneType-object"><a href="#7-cannot-unpack-non-iterable-NoneType-object" class="headerlink" title="7.cannot unpack non-iterable NoneType object"></a>7.cannot unpack non-iterable NoneType object</h1><p><strong>报错原因</strong>：将单个 None 赋给了多个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">1</span>:</span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a, b</span><br><span class="line"><span class="comment"># 无返回值时，返回None</span></span><br><span class="line">a, b = test()</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解决方法</strong></p><p>大多数情况是程序写错了导致返回的None，如果真的会返回None加入else 返回其他任意类型值，但注意得返回2个</p><h1 id="8-RuntimeError-Input-type-torch-cuda-FloatTensor-and-weight-type-torch-FloatTensor-should-be-the-same"><a href="#8-RuntimeError-Input-type-torch-cuda-FloatTensor-and-weight-type-torch-FloatTensor-should-be-the-same" class="headerlink" title="8.RuntimeError: Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same"></a>8.RuntimeError: Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same</h1><p><strong>报错原因</strong>：</p><ul><li>输入的数据类型为<code>torch.cuda.FloatTensor</code>，说明输入数据在GPU中</li><li>模型参数的数据类型为<code>torch.FloatTensor</code>，说明模型还在CPU</li></ul><p><strong>解决方法</strong>：将模型加载到gpu</p><ol><li><code>model = model.cuda()</code></li><li><code>model = model.to(&#39;cuda&#39;)</code></li><li><code>model.cuda()</code></li><li><code>model.to(&#39;cuda&#39;)</code></li></ol><p> 反之就是数据没移到gpu</p><ol><li><code>tensor = tensor.cuda()</code></li><li><code>tensor = tensor.to(&#39;cuda&#39;)</code></li></ol><p>但要注意直接<code>tensor.to(&#39;cuda&#39;)</code>等方法不行，</p><p>原因：<code>Module.to()</code> 是一个“in-place”方法，<code>tensor.to()</code> 函数不是。<code>tensor.to()</code> 这个函数功能是产生一个新的tensor，并不会改变原数据。</p><p>数据在gpu、cpu的调用：<code>x=x.cuda() </code>, <code>x=x.gpu()</code></p><h1 id="9-Tensor-object-has-no-attribute-cdua"><a href="#9-Tensor-object-has-no-attribute-cdua" class="headerlink" title="9.Tensor  object has no attribute  cdua"></a>9.Tensor  object has no attribute  cdua</h1><p>将数据移动到gpu时报错，<code>x=x.cuda()</code> ,很奇怪，<code>x=x.to(cuda)</code>没有报错。</p><p>过了一会 <code>x=x.cuda()</code> 又能运行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录使用pycharm时出现错误和警告&lt;/p&gt;</summary>
    
    
    
    <category term="日志" scheme="https://yilp.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="python" scheme="https://yilp.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pytorch官方文档查询记录</title>
    <link href="https://yilp.github.io/2022/08/11/pytorch%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95/"/>
    <id>https://yilp.github.io/2022/08/11/pytorch%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95/</id>
    <published>2022-08-11T01:39:51.000Z</published>
    <updated>2022-09-15T08:01:16.767Z</updated>
    
    <content type="html"><![CDATA[<p>记录查询过官方文档的知识点</p><span id="more"></span><h1 id="1-CONV2D"><a href="#1-CONV2D" class="headerlink" title="1.CONV2D"></a>1.CONV2D</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span>, padding_mode=<span class="string">&#x27;zeros&#x27;</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels in the input image</li><li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels produced by the convolution</li><li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a>) – Size of the convolving kernel</li><li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Stride of the convolution. Default: 1</li><li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>optional</em>) – Padding added to all four sides of the input. Default: 0</li><li><strong>padding_mode</strong> (<em>string</em><em>,</em> <em>optional</em>) – <code>&#39;zeros&#39;</code>, <code>&#39;reflect&#39;</code>, <code>&#39;replicate&#39;</code> or <code>&#39;circular&#39;</code>. Default: <code>&#39;zeros&#39;</code></li><li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Spacing between kernel elements. Default: 1</li><li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>optional</em>) – Number of blocked connections from input channels to output channels. Default: 1</li><li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>optional</em>) – If <code>True</code>, adds a learnable bias to the output. Default: <code>True</code></li></ul><p>注意：<code>padding=&#39;valid&#39;</code> is the same as no padding. <code>padding=&#39;same&#39;</code> pads the input so the output has the shape as the input. However, this mode doesn’t support any stride values other than 1.</p><p>torch默认数据类型float32</p><h1 id="2-nn-AdaptiveAvgPool2d（output-size）"><a href="#2-nn-AdaptiveAvgPool2d（output-size）" class="headerlink" title="2.nn.AdaptiveAvgPool2d（output_size）"></a>2.nn.AdaptiveAvgPool2d（output_size）</h1><p>输出形状可以是H*W，这种可以用一个元组表示(H, W)。</p><p>也可以是一个单独的H，表示输出为H*H</p><p>也可以是(H，None),None， None表示与输入一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target output size of 5x7</span></span><br><span class="line">m = nn.AdaptiveAvgPool2d((<span class="number">5</span>,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">64</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target output size of 7x7 (square)</span></span><br><span class="line">m = nn.AdaptiveAvgPool2d(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">64</span>, <span class="number">10</span>, <span class="number">9</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target output size of 10x7</span></span><br><span class="line">m = nn.AdaptiveAvgPool2d((<span class="literal">None</span>, <span class="number">7</span>))</span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">64</span>, <span class="number">10</span>, <span class="number">9</span>)</span><br><span class="line">output = m(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><h1 id="3-torch-nn-BATCHNORM2D"><a href="#3-torch-nn-BATCHNORM2D" class="headerlink" title="3.torch.nn.BATCHNORM2D"></a>3.torch.nn.BATCHNORM2D</h1><p>在 4D 输入（具有附加通道维度的小批量 2D 输入）上应用批量标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况</span></span><br><span class="line">torch.nn.BatchNorm2d(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><p><strong>num_features</strong> – C,   <em>C</em> 来自于输入 (N, C, H, W)。一般只输入这个参数</p></li><li><p><strong>eps</strong> –稳定系数，防止分母出现0。 Default: 1e-5</p></li><li><p><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1 。BatchNorm2d里面存储均值（running_mean）和方差（running_var）更新时的参数。这个动量参数不同于优化器类和传统的动量概念</p></li><li><p><strong>affine</strong> –  <code>True</code>代表gamma，beta是否可学。如果设为True，代表两个参数是通过学习得到的；如果设为False，代表两个参数是固定值，默认情况下，gamma是1，beta是0</p></li><li><p><strong>track_running_stats</strong> –BatchNorm2d中存储的的均值和方差是否需要更新，若为True，表示需要更新；反之不需要更新</p></li><li><p>```python</p><h1 id="With-Learnable-Parameters"><a href="#With-Learnable-Parameters" class="headerlink" title="With Learnable Parameters"></a>With Learnable Parameters</h1><p>m = nn.BatchNorm2d(100)</p><h1 id="Without-Learnable-Parameters"><a href="#Without-Learnable-Parameters" class="headerlink" title="Without Learnable Parameters"></a>Without Learnable Parameters</h1><p>m = nn.BatchNorm2d(100, affine=False)<br>input = torch.randn(20, 100, 35, 45)<br>output = m(input)</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  批量规范化： 对于**所有的batch**中样本的**同一个channel**的数据元素进行标准化处理，即样本如果有C个通道，无论batch中有多少个样本，都会在通道维度上进行标准化处理，一共进行C次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">训练阶段， track_running_stats<span class="operator">=</span><span class="keyword">true</span>，模型事先存储了各个通道的均值和方差初始值。每当一个batch的数据规范化时，利用此时计算得到的局部观测值更新存储的均值和方差，使之具有全局数据的统计特性。</span><br><span class="line"></span><br><span class="line">测试阶段，track_running_stats<span class="operator">=</span><span class="keyword">true</span>，模型处于测试阶段，测试数据时，仍要规范化。需要考虑存储的均值和方差，但不会更新。</span><br><span class="line"></span><br><span class="line">详细连接：https://blog.csdn.net/ChaoFeiLi/article/details/<span class="number">124847167</span>?ops_request_misc<span class="operator">=</span><span class="variable">%257</span>B<span class="variable">%2522</span>request<span class="variable">%255</span>Fid<span class="variable">%2522</span><span class="variable">%253</span>A<span class="variable">%2522166104928116782395318256</span><span class="variable">%2522</span><span class="variable">%252</span>C<span class="variable">%2522</span>scm<span class="variable">%2522</span><span class="variable">%253</span>A<span class="variable">%252220140713</span>.<span class="number">130102334</span>..<span class="variable">%2522</span><span class="variable">%257</span>D&amp;request_id<span class="operator">=</span><span class="number">166104928116782395318256</span>&amp;biz_id<span class="operator">=</span><span class="number">0</span>&amp;utm_medium<span class="operator">=</span>distribute.pc_search_result.none-task-blog<span class="number">-2</span>~blog~sobaiduend~<span class="keyword">default</span><span class="number">-2</span><span class="number">-124847167</span>-<span class="keyword">null</span>-<span class="keyword">null</span>.nonecase&amp;utm_term<span class="operator">=</span>batchnorm<span class="number">2</span>d<span class="variable">%E4</span><span class="variable">%BD</span><span class="variable">%9</span>C<span class="variable">%E7</span><span class="variable">%94</span><span class="variable">%A8</span>&amp;spm<span class="operator">=</span><span class="number">1018.2226</span>.<span class="number">3001.4450</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>.torchvision.datasets.imagefolder()</span><br><span class="line"></span><br><span class="line">加载各类标签在文件夹上的数据集</span><br><span class="line"></span><br><span class="line">默认情况下以这种方式排列的图像的 通用数据加载器</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">root/dog/xxx.png</span><br><span class="line">root/dog/xxy.png</span><br><span class="line">root/dog/[...]/xxz.png</span><br><span class="line"></span><br><span class="line">root/cat/<span class="number">123</span>.png</span><br><span class="line">root/cat/nsdf<span class="number">3</span>.png</span><br><span class="line">root/cat/[...]/asd<span class="number">932</span>_.png</span><br></pre></td></tr></table></figure></li></ul><p><strong>root (string)</strong> – 根目录路径。</p><p><strong>transform (callable, optional)</strong> – 一个函数/转换，它接受一个 PIL 图像并返回一个转换后的版本。</p><p><strong>loader (callable, optional)</strong> – 加载给定路径的图像的函数。</p><p><strong>is_valid_file</strong> – 获取图像文件路径并检查文件是否为有效文件的函数（用于检查损坏的文件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录查询过官方文档的知识点&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="https://yilp.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="python" scheme="https://yilp.github.io/tags/python/"/>
    
    <category term="pytorch" scheme="https://yilp.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>一间低夹定式</title>
    <link href="https://yilp.github.io/2022/08/10/%E4%B8%80%E9%97%B4%E4%BD%8E%E5%A4%B9%E5%AE%9A%E5%BC%8F/"/>
    <id>https://yilp.github.io/2022/08/10/%E4%B8%80%E9%97%B4%E4%BD%8E%E5%A4%B9%E5%AE%9A%E5%BC%8F/</id>
    <published>2022-08-10T11:16:19.000Z</published>
    <updated>2022-08-13T12:11:33.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="星位的一间低夹定式及双方变化"><a href="#星位的一间低夹定式及双方变化" class="headerlink" title="星位的一间低夹定式及双方变化"></a><strong>星位的一间低夹定式及双方变化</strong></h1><span id="more"></span><p>黑棋夹后，白棋有 <strong>点、跳、飞</strong> 三种应对方式</p><h2 id="一、白棋飞"><a href="#一、白棋飞" class="headerlink" title="一、白棋飞"></a>一、白棋飞</h2><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E4%B8%80%E9%97%B4%E4%BD%8E%E5%A4%B9-%E9%A3%9E-.png" alt="一间低夹-白飞-"></p><p>到这样，白棋又有点三三、 托两种下法</p><h3 id="—点"><a href="#—点" class="headerlink" title="—点"></a>—点</h3><p><strong>1</strong>.黑棋扳三三，黑棋出错打吃而没有挡住</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B13%E5%87%BA%E9%94%99.png" alt="白棋点之黑棋出错"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E6%AD%A3%E7%A1%AE%E4%B8%8B%E6%B3%95.png" alt="QQ截图20220810190138"></p><p><strong>2</strong>.黑棋打吃，布局结束，黑棋获得先手</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%919%E6%89%93%E5%90%83.png" alt="白棋点之黑棋打吃黑棋获得先手"></p><h2 id="—托"><a href="#—托" class="headerlink" title="—托"></a>—托</h2><p><strong>1</strong>.黑棋扳</p><p>白棋出错</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E7%99%BD14%E5%BA%94%E5%BD%93%E5%86%B2%E9%BB%9115.png" alt="白棋托出错"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E6%89%B3%E6%AD%A3%E7%A1%AE%E4%B8%8B%E6%B3%95.png" alt="白棋托之黑棋扳"></p><p>**2.**黑棋打吃</p><p>黑棋扳不满意</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E6%89%93%E5%90%83.png" alt="白棋托之黑棋打吃"></p><h2 id="二、白棋跳"><a href="#二、白棋跳" class="headerlink" title="二、白棋跳"></a>二、白棋跳</h2><p>黑棋有尖三三和尖顶白2的下法</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E5%B0%96%E4%B8%89%E4%B8%89.png" alt="黑棋尖三三"></p><p>但当黑棋下方有棋可以围空的时候，就不应该尖三三，否则后面下法很吃亏</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E4%B8%8B%E6%96%B9%E6%9C%89%E6%A3%8B%E7%9A%84%E6%83%85%E5%86%B5.png" alt="黑棋下方有棋"></p><h2 id="二间低夹时"><a href="#二间低夹时" class="headerlink" title="二间低夹时"></a>二间低夹时</h2><p><strong>2.二间扳粘跳出去</strong></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E6%98%9F%E4%BD%8D%E4%BD%8E%E5%A4%B9%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9A%E5%BC%8F.png" alt="二间扳粘跳出去"></p><p><strong>2.双飞燕</strong></p><p>白8应当点三三，而不是长2（黑1挡）</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E5%8F%8C%E9%A3%9E%E7%87%95.png" alt="双飞燕"></p><p>黑9挡白8（白10位置），则黑棋吃亏，白棋满意</p><p><strong>黑棋可能的两种下法两种</strong></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E6%96%AD.png" alt="黑棋断"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/%E9%BB%91%E6%A3%8B%E5%86%B2.png" alt="黑棋冲"></p><h2 id="二间低高夹时"><a href="#二间低高夹时" class="headerlink" title="二间低高夹时"></a>二间低高夹时</h2><p>点角</p><p>双飞燕</p><p>跳出来 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;星位的一间低夹定式及双方变化&quot;&gt;&lt;a href=&quot;#星位的一间低夹定式及双方变化&quot; class=&quot;headerlink&quot; title=&quot;星位的一间低夹定式及双方变化&quot;&gt;&lt;/a&gt;&lt;strong&gt;星位的一间低夹定式及双方变化&lt;/strong&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="围棋" scheme="https://yilp.github.io/categories/%E5%9B%B4%E6%A3%8B/"/>
    
    
    <category term="生活" scheme="https://yilp.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="围棋" scheme="https://yilp.github.io/tags/%E5%9B%B4%E6%A3%8B/"/>
    
  </entry>
  
  <entry>
    <title>围棋-邱百瑞</title>
    <link href="https://yilp.github.io/2022/08/07/%E5%9B%B4%E6%A3%8B-%E9%82%B1%E7%99%BE%E7%91%9E/"/>
    <id>https://yilp.github.io/2022/08/07/%E5%9B%B4%E6%A3%8B-%E9%82%B1%E7%99%BE%E7%91%9E/</id>
    <published>2022-08-07T12:54:40.000Z</published>
    <updated>2022-08-11T08:51:01.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本落子规则和胜利条件"><a href="#1-基本落子规则和胜利条件" class="headerlink" title="1.基本落子规则和胜利条件"></a>1.基本落子规则和胜利条件</h1><p>黑线白后（黑先对局结束后要还白棋），4星位，中天元</p><span id="more"></span><p><strong>打吃</strong>：2口气变1口气</p><p><strong>死棋</strong>：无气</p><p><strong>获胜条件</strong>：谁占的交叉点多胜利，地盘大（活棋和包围的地盘），占领地盘的棋子首先得活着</p><p><strong>眼</strong>:一整块的棋包围的交叉点，下不进去（包围交叉点多就叫“空”，需要学习是否在空、大眼里分割眼，双方就有先手活、后手死等）</p><p><strong>眼的叫法根据形状</strong>：直三、四，弯三，闪电四，判断、找到同时占领做活的点</p><p><strong>大眼</strong>：2个做眼（做出两眼）的位置，活//1个做眼的位置，先手活，后手死。0个做眼的位置，死</p><p><strong>假眼</strong>：看着像眼</p><p><strong>活棋</strong>：永远不会被吃</p><p><strong>线</strong>：同一线的棋子属性差不多。最外一圈叫一线。三线和四线的位置是好位置，优先占领。</p><p><strong>优先占角</strong>：围空花费的棋子、做眼的角度：角上&lt;边上&lt;中央——金角银边草肚皮（棋盘上没棋子时的价值判断）。所以<strong>优先下的位置</strong>为<strong>星位</strong>，星位下的位置叫<strong>小目</strong>，斜对角叫<strong>三三</strong>   。双方占完角后，朝中央发展</p><h1 id="2-行棋步伐"><a href="#2-行棋步伐" class="headerlink" title="2.行棋步伐"></a>2.行棋步伐</h1><p><strong>封锁线</strong>：棋子和棋子和边间隔2个距离就形成了封锁线，就封锁了地盘</p><p><strong>步伐</strong>：尖（2个棋子斜着，结实）、飞（2个棋子马，快），大飞，超大飞，拆一（横着间隔），跳（竖着从一条线到另一条线），立（2个挨着）</p><p>打劫：被吃了不能立马吃回来，必须在外下一手</p><h1 id="3-棋子间的联系"><a href="#3-棋子间的联系" class="headerlink" title="3.棋子间的联系"></a>3.棋子间的联系</h1><p>1个棋子基本能影响4个气和4个斜角（下棋先做到不吃亏），<strong>一般情况</strong>下行棋有分寸，对方一个棋子，我们下棋距离1个距离</p><p>和自己的棋子，1个棋子2个距离，2个棋子3个距离。</p><p>对方下棋碰上来，<strong>逢碰必板</strong>（改变对方行进方向）</p><p><strong>逢板必退</strong>：给自己的棋子长气</p><p><strong>扭十字长一边，哪边弱长哪边</strong>：出现扭十字后，不要着急进攻。</p><p>打吃容易出事情：就是打吃没吃掉，别人气长了，而自己的棋子是分开的，</p><p>学这些是明白下棋得有<strong>分寸感</strong>，和自己、对方的棋子保持距离</p><h1 id="4-接触战-连接和分断"><a href="#4-接触战-连接和分断" class="headerlink" title="4.接触战-连接和分断"></a>4.接触战-连接和分断</h1><p><strong>连接</strong></p><p>1.粘，直接下断点将棋子连接</p><p>2.斜（尖）：利用围棋规则，有两个断点，对方破坏1个，我们连上另1个</p><p>3.虎，下个虎口，虽然棋子没连接，但对方没法下断点</p><p> 双虎：</p><p><strong>4.虎补</strong>，通过飞来控制断点</p><p>5.双</p><h1 id="5-判断棋子重要程度"><a href="#5-判断棋子重要程度" class="headerlink" title="5.判断棋子重要程度"></a>5.判断棋子重要程度</h1><p><strong>棋筋</strong>：起到连接和分段的棋子–优先消灭/保护</p><p><strong>废子</strong>：对做活没有用，不必理会</p><p><strong>干子</strong>：普通的子</p><p>不要根据数量来判断</p><p><strong>判断在先，手段在后</strong></p><h1 id="6-吃子技巧–双打吃"><a href="#6-吃子技巧–双打吃" class="headerlink" title="6.吃子技巧–双打吃"></a>6.吃子技巧–双打吃</h1><p><strong>双打吃</strong>：一步棋打吃2个棋子（形成的条件：有断点，气紧-少，所以要自己制造、避免 ）</p><p><strong>适用范围</strong>：吃棋筋子、大块子</p><p>吃子的时候要分析值不值得吃</p><p><strong>向下吃</strong>：一般针对2、3线的棋子，利用围棋的边界</p><p><strong>关门吃</strong>：</p><p><strong>抱吃</strong>：</p><p><strong>吃子时追赶敌人把敌人朝着我们强的地方赶</strong></p><h1 id="围棋入门"><a href="#围棋入门" class="headerlink" title="围棋入门"></a><strong>围棋入门</strong></h1><h2 id="4围地的常识"><a href="#4围地的常识" class="headerlink" title="-4围地的常识"></a>-4围地的常识</h2><p>占角拆边围中间</p><p>拆二围地比较保险，围三/四线，一般围地的手法是拆二、小飞、大飞（顺序不一）</p><p>尖或者小飞守角</p><h2 id="5对杀的常识"><a href="#5对杀的常识" class="headerlink" title="-5对杀的常识"></a>-5对杀的常识</h2><p><strong>对杀</strong>：互相包围了，只有杀了对方才能活，关键比气</p><p>对杀的时候先紧外气（对方的气），不要走到公气，否则等于没走，气多也可能输（眼的那气不算外气）。公气越多，越可能双活。</p><p>有眼的和没眼的对杀，几乎不可能双活。有眼的不要走公气，无眼的一定要走完公气后才有可能杀掉对。</p><p>对杀时先做眼，阻止对方做眼，做出眼后留出了公气，占优势（公气越多优势越大）。</p><h2 id="6大小与先后手"><a href="#6大小与先后手" class="headerlink" title="-6大小与先后手"></a>-6大小与先后手</h2><p>每一手下了都会有价值，下了一子吃了1目，多了1个空格，则价值为2目</p><p><strong>单官</strong>：下了没有价值</p><p>下完了之后把吃了的子放回各自的领地里</p><p>先手：下先迫使对方抵挡，先手非常重要</p><h2 id="7关于吃子的几个问题"><a href="#7关于吃子的几个问题" class="headerlink" title="-7关于吃子的几个问题"></a>-7关于吃子的几个问题</h2><p>-能杀对方：</p><p>兵多</p><p>对方断点多</p><p>在边上，出路少</p><p>同时杀棋时把对方往边上赶，往自己人多地方赶，同时追杀棋时如果出现断点一定要注意，不要盲目杀棋</p><h1 id="布局的要领"><a href="#布局的要领" class="headerlink" title="布局的要领"></a>布局的要领</h1><h2 id="1占角、挂角、根据地"><a href="#1占角、挂角、根据地" class="headerlink" title="-1占角、挂角、根据地"></a>-1占角、挂角、根据地</h2><p>挂角：小飞挂（最常用）、一间高挂、二间高挂</p><p>不同位置的挂角：</p><p>守角：对星位的守角，小飞、大飞、边角</p><p>布局的重要手段：拆（下对方拆的地方，叫架）。两个子就可拆三</p><h2 id="2分投、大场"><a href="#2分投、大场" class="headerlink" title="-2分投、大场"></a>-2分投、大场</h2><p>分投：投在对方的阵地，两边都可拆（二）</p><p>大场：中间1那个点</p><h2 id="3有关根据-4有关出路"><a href="#3有关根据-4有关出路" class="headerlink" title="-3有关根据 4有关出路"></a>-3有关根据 4有关出路</h2><p>快被包围的时候可以跳逃出去</p><p>下棋寻找没有安定的棋</p><p><strong>占地比吃子更重要</strong></p><p>活棋要尽量能照顾其他地方</p><p><strong>布局的时候下棋看下的棋和根据地、出路有无关系</strong></p><h2 id="5布局常见错误-拆二、根据和官子"><a href="#5布局常见错误-拆二、根据和官子" class="headerlink" title="-5布局常见错误-拆二、根据和官子"></a><strong>-5布局常见错误-拆二、根据和官子</strong></h2><p> 双方已经碰撞了，要注意</p><p>围棋眼界要宽阔，要大胆，也不要小小缩边围地</p><h2 id="6布局常见错误-一味围地、劳力重复"><a href="#6布局常见错误-一味围地、劳力重复" class="headerlink" title="-6布局常见错误-一味围地、劳力重复"></a><strong>-6布局常见错误-一味围地、劳力重复</strong></h2><p>已经活了的棋不需要照顾，</p><p>活棋会师也没有效率 </p><h2 id="7布局-三连星"><a href="#7布局-三连星" class="headerlink" title="-7布局-三连星"></a><strong>-7布局-三连星</strong></h2><p>小目控角、目外占边、高目中间，星位三者兼顾</p><p>初中级常用的布局，非常实用</p><p>比如对手在内部小飞挂，尖顶定式，大场继续尖顶进攻挖根</p><p>对手小飞挂，我方使用夹攻击，对手点三三，防御得把对手挡在三连星外</p><h2 id="8布局-中国流"><a href="#8布局-中国流" class="headerlink" title="-8布局-中国流"></a><strong>-8布局-中国流</strong></h2><p>初期，日本很强，中国在定式这些理论方面很弱，但中盘厮杀能力可以，于是开发出了中国流，针对日本棋手，追求快速布局，进入战斗。</p><hr><h1 id="定式的要点"><a href="#定式的要点" class="headerlink" title="定式的要点"></a>定式的要点</h1><h2 id="1得失的判断"><a href="#1得失的判断" class="headerlink" title="-1得失的判断"></a>-1得失的判断</h2><p><strong>开局情况（双方可以接受）</strong></p><p>1、双方一半一半</p><p>2、一个实地，一个外势。水平一般要实地实惠，但最好要外势锻炼（股票和现金）</p><p>3、直接对杀</p><h2 id="2着手的意义、连络与切断、出头与封头、根据地"><a href="#2着手的意义、连络与切断、出头与封头、根据地" class="headerlink" title="-2着手的意义、连络与切断、出头与封头、根据地"></a>-2着手的意义、连络与切断、出头与封头、根据地</h2><p>定式就是包含了 连络与切断、出头与封头、根据地，<strong>每手棋基本就这几个作用。</strong></p><p><strong>下棋只要符合基本原则就不会出太大的错</strong></p><p><strong>出头封头很重要</strong></p><h2 id="3星、小飞挂"><a href="#3星、小飞挂" class="headerlink" title="-3星、小飞挂"></a>-3星、小飞挂</h2><p>小飞挂是最常见的</p><p><strong>像尖顶定式一般是有棋子防止对面拆二才用</strong></p><p><strong>别人打自己弱点，自己也要注意对面弱点，打过去</strong></p><p><strong>老老实实下棋没法提升</strong></p><p><strong>送对面一子来布局，不得贪吃</strong></p><p><strong>定式知道这种下法就行，具体看变化</strong></p><p><strong>一打一接</strong></p><h2 id="4小目"><a href="#4小目" class="headerlink" title="-4小目"></a>-4小目</h2><p>小飞挂</p><p>应对：1.尖守（很稳定） 、小飞、拆二</p><p>​            2 夹 （现在常用的，对手跳）</p><h2 id="5高挂"><a href="#5高挂" class="headerlink" title="-5高挂"></a>-5高挂</h2><h2 id="6目外、高目、三三"><a href="#6目外、高目、三三" class="headerlink" title="-6目外、高目、三三"></a>-6目外、高目、三三</h2><hr><h1 id="死活的关键"><a href="#死活的关键" class="headerlink" title="死活的关键"></a>死活的关键</h1><h2 id="1基本手段-扩大与缩小眼位"><a href="#1基本手段-扩大与缩小眼位" class="headerlink" title="-1基本手段-扩大与缩小眼位"></a>-1基本手段-扩大与缩小眼位</h2><p>2路六死八活、3路四死六活</p><p>二一路很重要</p><p>缩小眼位要注意力度够不够</p><p>缩小眼位：1. 一路板（如 扑）  2.内部</p><p>哪扩大，哪缩小，变成基本型</p><h2 id="2基本手段-做眼和点眼"><a href="#2基本手段-做眼和点眼" class="headerlink" title="-2基本手段-做眼和点眼"></a>-2基本手段-做眼和点眼</h2><p>做眼:用最小的地方做个眼</p><p>点眼：让对方浪费地方才能做眼，阻止对方做眼</p><p>缩眼不行就考虑点眼 </p><p>扩大眼位不行就做眼</p><h2 id="3基本手段-眼形要点"><a href="#3基本手段-眼形要点" class="headerlink" title="-3基本手段-眼形要点"></a>-3基本手段-眼形要点</h2><p>直的眼位和弯的眼位容易活，特别是弯的</p><p>方的和圆的容易死</p><h2 id="4基本手段-二一路"><a href="#4基本手段-二一路" class="headerlink" title="-4基本手段-二一路"></a>-4基本手段-二一路</h2><p>考虑死活的方案时，还要考虑对方的破坏</p><p><strong>要多注意二一路</strong>    角上死活很重要的要点</p><h2 id="5基本手段-点方"><a href="#5基本手段-点方" class="headerlink" title="-5基本手段-点方"></a>-5基本手段-点方</h2><p>死活时 田的对角</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727133014.png" alt="QQ截图20220727133014"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727132554.png" alt="QQ截图20220727132554"></p><h2 id="6基本手段-扑与防扑"><a href="#6基本手段-扑与防扑" class="headerlink" title="-6基本手段-扑与防扑"></a>-6基本手段-扑与防扑</h2><p>扑来破眼，比如点眼扑再扑</p><p>防扑：想办法吃3子，或者先手吃2子</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727133318.png" alt="QQ截图20220727133318"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727133503.png" alt="QQ截图20220727133503"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727134026.png" alt="QQ截图20220727134026"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727135431.png" alt="QQ截图20220727135431"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727135538.png" alt="QQ截图20220727135538"></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727135901.png" alt="QQ截图20220727135901"></p><h2 id="7基本形-角部基本型"><a href="#7基本形-角部基本型" class="headerlink" title="-7基本形-角部基本型"></a>-7基本形-角部基本型</h2><p><strong>直三·曲三一点死，丁四·刀五一点亡。花五·花六眼虽大，中间一点也白忙。</strong></p><p><strong>直四·曲四和板六，够做两眼不用慌。</strong></p><p>死棋</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727140336.png" alt="QQ截图20220727140336"></p><p>多一路（黑棋先板则变死棋形状，所以白棋先得占个二一路就活了）</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727141221.png" alt="QQ截图20220727141221"></p><p>活棋</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727141455.png" alt="QQ截图20220727141455"></p><p>活棋</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727140712.png" alt="QQ截图20220727140712"></p><p>白棋多了个板</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727141704.png" alt="QQ截图20220727141704"></p><p>黑棋下面先板则白死了，如果黑棋扑则错了，或者黑点方</p><p>白棋点二一路</p><p>下面有个板</p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727142022.png" alt="QQ截图20220727142022"></p><h2 id="8基本形-小猪嘴型"><a href="#8基本形-小猪嘴型" class="headerlink" title="-8基本形-小猪嘴型"></a>-8基本形-小猪嘴型</h2><h2 id="9基本形-大猪嘴型"><a href="#9基本形-大猪嘴型" class="headerlink" title="-9基本形-大猪嘴型"></a>-9基本形-大猪嘴型</h2><h2 id="10基本形-金柜角型"><a href="#10基本形-金柜角型" class="headerlink" title="-10基本形-金柜角型"></a>-10基本形-金柜角型</h2><h2 id="11基本形-实战常见型"><a href="#11基本形-实战常见型" class="headerlink" title="-11基本形-实战常见型"></a>-11基本形-实战常见型</h2><h2 id="12基本形-边上基本型"><a href="#12基本形-边上基本型" class="headerlink" title="-12基本形-边上基本型"></a>-12基本形-边上基本型</h2><p>中间有气，两边至少有一个有气</p><p><strong>盘角曲四</strong></p><p><img src="https://typora1111.oss-cn-chengdu.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20220727152248.png" alt="QQ截图20220727152248"></p><p><strong>盘角曲四</strong>，劫尽棋亡。<br>等到全部单官收完以后，点进去， 对方只好扑劫， 提劫， 此时全场无劫财， 所以是死棋。</p><p>所以，盘角曲四得把全局劫材补完后再下，有双活就不一样了。</p><p>盘角的曲四五应该都有死的</p><p><strong>打劫</strong>：谁下谁吃</p><p><strong>劫材</strong>：打劫后，由于不能立即提回，需在其他地方下一手，如果迫使对方应一手，则可以称这一手为劫材</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-基本落子规则和胜利条件&quot;&gt;&lt;a href=&quot;#1-基本落子规则和胜利条件&quot; class=&quot;headerlink&quot; title=&quot;1.基本落子规则和胜利条件&quot;&gt;&lt;/a&gt;1.基本落子规则和胜利条件&lt;/h1&gt;&lt;p&gt;黑线白后（黑先对局结束后要还白棋），4星位，中天元&lt;/p&gt;</summary>
    
    
    
    <category term="围棋" scheme="https://yilp.github.io/categories/%E5%9B%B4%E6%A3%8B/"/>
    
    
    <category term="生活" scheme="https://yilp.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="围棋" scheme="https://yilp.github.io/tags/%E5%9B%B4%E6%A3%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于hexo的博客搭建</title>
    <link href="https://yilp.github.io/2022/08/07/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://yilp.github.io/2022/08/07/%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-07T12:10:27.000Z</published>
    <updated>2022-09-12T06:57:44.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p>官网安装好Nodejs，除了安装路径，一路next安装</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bash #进入根目录</span><br><span class="line">node -v#查看node版本</span><br><span class="line">node -v#查看node版本</span><br></pre></td></tr></table></figure><h2 id="2-安装hexo框架"><a href="#2-安装hexo框架" class="headerlink" title="2.安装hexo框架"></a>2.安装hexo框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br></pre></td></tr></table></figure><h2 id="3-配置个人博客"><a href="#3-配置个人博客" class="headerlink" title="3.配置个人博客"></a>3.配置个人博客</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog#创建blog目录 本文件夹包含博客的所有东西，配置出错删除重来即可</span><br><span class="line">cd blog #进入blog目录</span><br><span class="line">hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务 访问 http://localhost:4000/ 即可看到本地博客</span><br><span class="line">hexo n &quot;我的第一篇文章&quot; #创建新的文章 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">返回blog目录</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写、改文章后的必要操作</span></span><br><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure><h2 id="4-利用GitHub部署到远端"><a href="#4-利用GitHub部署到远端" class="headerlink" title="4.利用GitHub部署到远端"></a>4.利用GitHub部署到远端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个新仓库，命名为 GitHub的用户名.github.io</span></span><br><span class="line">cnpm install --save hexo-deployer-git # 在blog目录下部署git插件</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置blog目录下的 _config.yml 文件----非常重要的文件，后续还可修改博客风格</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">hexo d#部署到Github仓库里 https://Name.github.io/ 可以查看博客</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每次写好文章后，现在本地服务器查看有无错误，再上传</span></span><br></pre></td></tr></table></figure><h2 id="5-修改主题"><a href="#5-修改主题" class="headerlink" title="5.修改主题"></a>5.修改主题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">修改blog目录下的 _config.yml 文件 ： theme: yilia</span></span><br><span class="line"> hexo c#清理一下</span><br><span class="line">hexo g#生成</span><br><span class="line">hexo d#部署到远程Github仓库</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwd # 显示当前路径</span><br><span class="line">cd #更改路径</span><br><span class="line"><span class="meta prompt_">mkdir#</span><span class="language-bash">创建文件夹</span></span><br><span class="line">cd ../../ #返回上两级目录</span><br><span class="line">ls -l #显示文件列表</span><br></pre></td></tr></table></figure><h2 id="博客搭好写、传文章"><a href="#博客搭好写、传文章" class="headerlink" title="博客搭好写、传文章"></a>博客搭好写、传文章</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章名&quot; #改不需要这一步</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在本地写好后</span></span><br><span class="line">hexo clean #最好clean 不要</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-安装Nodejs&quot;&gt;&lt;a href=&quot;#1-安装Nodejs&quot; class=&quot;headerlink&quot; title=&quot;1.安装Nodejs&quot;&gt;&lt;/a&gt;1.安装Nodejs&lt;/h2&gt;&lt;p&gt;官网安装好Nodejs，除了安装路径，一路next安装&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://yilp.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="环境搭建" scheme="https://yilp.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="博客" scheme="https://yilp.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo命令</title>
    <link href="https://yilp.github.io/2022/08/07/hello-world/"/>
    <id>https://yilp.github.io/2022/08/07/hello-world/</id>
    <published>2022-08-07T07:28:22.556Z</published>
    <updated>2022-08-08T07:00:46.027Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://yilp.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="环境搭建" scheme="https://yilp.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="博客" scheme="https://yilp.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
